## Uniswap V2 Library Code Walkthrough

## Uniswap V2 Library

The Uniswap V2 Library simplifies some interactions with pair contracts and is used heavily by the Router contracts. It contains eight functions that are not state-changing. They are also handy for integrating Uniswap V2 from a smart contract.

## getAmountOut() and getAmountIn()

If we want to predict the amount of toke y we will get if we supply a fixed amount of token x, then we can derive the amount out using the sequence below (ignoring fees for simplicity). Let x be the incoming token, y be the outgoing token, ∆x be the amount coming in an ∆y be the amount going out.

$$
  xy = (x + \Delta x)(y - \Delta y) \\[1em]
  y - \Delta y = \frac{xy}{x + \Delta x} \\[1em]
  - \Delta y = \frac{xy - y(x + \Delta x)}{x + \Delta x} \\[1em]
  - \Delta y = \frac{-y \Delta x}{x + \Delta x} \\[1em]
  \Delta y = \frac{y \Delta x}{x + \Delta x} \\[1em]
  \text{amount\_out} = \frac{\text{reserve\_out} \cdot \text{amount\_in}}{\text{reserve\_in} + \text{amount\_in}}
$$

The core principle of Uniswap V2 is the constant product formula:

$x$ x $y$ = $k$

where:

- $x$: reserve of token X (before the swap)
- $y$: reserve of token Y (before the swap)
- $k$: constant (must remain unchanged)

The product $x$ x $y$ must stay constant _before_ and _after_ swap (ignoring fees)

### Step-by-step Derivation

1. A user adds ∆x to token X:

- They input more of token X, so the pool's X balance becomes:
  - $x + \Delta x$
- To keep $x$ x $y$ = $k$ constant, the Y balance must decrease. Let's defined:
  - $x - \Delta y$
- So the new product must still satisfy:
  - ($x + \Delta x$)($y - \Delta y$) = $xy$

2. Rearranging:

- We now solve this equation for $\Delta y$, which is the **amount of Y the user gets out**
  - $xy$ = ($x + \Delta x$)($y - \Delta y$)
  - $y - \Delta y = \frac{xy}{x + \Delta x}$
  - $\Delta y = \frac{{xy - y}(x + \Delta x)}{x + \Delta x}$
  - $\Delta y = \frac{-y \Delta x}{x + \Delta x}$
  - $\Delta y = \frac{y \Delta x}{x + \Delta x}$

### Final Swap Formula (without fees)

The actual swap output amount $\Delta y$ is:

$\Delta y = \frac{y \cdot \Delta x}{x + \Delta x}$

The more you input ($\Delta x$), the more you get out - but with diminishing returns due to the denominator.

This reflects price slippage due to the AMM curve.

With that in mind, the function for getAmountOut() in the UniswapV2Library.sol should be self-explanatory. Note that the numbers are scaled by 1,0000 to account for the 0.3% fee. The derivation for getAmountIn() with fees is an exervise for the reader.

![library](/notes/images/uniswapv2-library.jpg)

## Chaining getAmountOut() to getAmoutsOut() for pair hops

### getAmountsOut() and getAmountsIn()

If a trader supplies a sequence of pairs, (A, B), (B, C), (C, D) and iteratively calls getAmountOut starting with a certain amount of A, then the amount of token D that will be received can be predicted.

The address of the UniswapV2 pair contract for each (A, B), (B, C), etc. is deterministically derived from the addresses of the tokens and the address of the factory that deployed the pair using the create2 function. Given two tokens (A, B) and a factory address, pairFor() derives the address of the pair UniswapV2 pool contract for that pair, using sortTokens() as a helper function.

![library-2](/notes/images/uniswapv2-library-2.jpeg)

Now that we knoe the addresses for all the pairs, we can get the reserves of each one and predict how much tokens we will receive at the end of the chain of swaps. Below is the code for getAmountsOut() (emphasis on "Amounts" instead of "Amount"). The functoin getAmountsIn() simply does the same thing in reverse so we won't show it here.

Note a couple things:

- The smart contract doesn't figure out the optimal sequence of pairs on its own, it needs to be told the list of pairs to calculate the chain of swaps over. This is best done off-chain.
- It doesn't just return the final token amountOut in the chain, but the amount out at every step.

![library-3](/notes/images/uniswapv2-library-3.jpg)

## getReserves()

The function getReserves is simply a wrapper around the function getReserves from the Uniswap V2 pair contract except that it also removes the timestamp when the price was last updated. The function for getReserves from the pair contract is also shown for easy comparison (purple comments).

![library-4](/notes/images/uniswapv2-library-4.jpg)

Core function:

![library-5](/notes/images/uniswapv2-library-5.jpg)

## quote()

Recall that the price of an asset follows the following formula:

$$
\text{price}(foo) = \frac{\text{reserve } (foo)}{\text{reserve } (bar)}
$$

This function returns the price of foo denominated in bar as of the last update. **This function should be used with care as it is vulnerable to flash loan attacks**.

![library-6](/notes/images/uniswapv2-library-6.jpg)

## Using UniswapV2Library

If you want to predict how much to put into or expect out of a trade, or a sequence of trades across pairs, the UniswapV2Library is the tool to use.
